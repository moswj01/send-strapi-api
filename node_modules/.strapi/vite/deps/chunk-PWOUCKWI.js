import {
  getIn,
  setIn
} from "./chunk-KSOT2AXF.js";
import {
  createContext
} from "./chunk-NHQIM62Q.js";
import {
  generateNKeysBetween
} from "./chunk-3DRZIGZ7.js";
import {
  require_isEqual
} from "./chunk-FPU5PDM4.js";
import {
  fn
} from "./chunk-QOUV5O5E.js";
import {
  Box,
  useCallbackRef,
  useComposedRefs,
  useIntl
} from "./chunk-JDIU5BXJ.js";
import {
  require_jsx_runtime
} from "./chunk-LMPM4PM5.js";
import {
  require_react
} from "./chunk-D3I3COXH.js";
import {
  __toESM
} from "./chunk-LK32TJAX.js";

// node_modules/@strapi/plugin-documentation/node_modules/@strapi/admin/dist/admin/admin/src/components/Form.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var React = __toESM(require_react(), 1);
var import_isEqual = __toESM(require_isEqual(), 1);

// node_modules/@strapi/plugin-documentation/node_modules/@strapi/admin/dist/admin/admin/src/hooks/useWarnIfUnsavedChanges.mjs
var import_react = __toESM(require_react(), 1);

// node_modules/@strapi/plugin-documentation/node_modules/@strapi/admin/dist/admin/admin/src/components/Form.mjs
var ERR_MSG = "The Form Component has not been initialised, ensure you are using this hook within a Form component";
var [FormProvider, useForm] = createContext("Form", {
  disabled: false,
  errors: {},
  initialValues: {},
  isSubmitting: false,
  modified: false,
  addFieldRow: () => {
    throw new Error(ERR_MSG);
  },
  moveFieldRow: () => {
    throw new Error(ERR_MSG);
  },
  onChange: () => {
    throw new Error(ERR_MSG);
  },
  removeFieldRow: () => {
    throw new Error(ERR_MSG);
  },
  resetForm: () => {
    throw new Error(ERR_MSG);
  },
  setErrors: () => {
    throw new Error(ERR_MSG);
  },
  setValues: () => {
    throw new Error(ERR_MSG);
  },
  setSubmitting: () => {
    throw new Error(ERR_MSG);
  },
  validate: async () => {
    throw new Error(ERR_MSG);
  },
  values: {}
});
var Form = React.forwardRef(({ disabled = false, method, onSubmit, initialErrors, ...props }, ref) => {
  const formRef = React.useRef(null);
  const initialValues = React.useRef(props.initialValues ?? {});
  const [state, dispatch] = React.useReducer(reducer, {
    errors: initialErrors ?? {},
    isSubmitting: false,
    values: props.initialValues ?? {}
  });
  React.useEffect(() => {
    if (!(0, import_isEqual.default)(initialValues.current, props.initialValues)) {
      initialValues.current = props.initialValues ?? {};
      dispatch({
        type: "SET_INITIAL_VALUES",
        payload: props.initialValues ?? {}
      });
    }
  }, [
    props.initialValues
  ]);
  const setErrors = React.useCallback((errors) => {
    dispatch({
      type: "SET_ERRORS",
      payload: errors
    });
  }, []);
  const setValues = React.useCallback((values) => {
    dispatch({
      type: "SET_VALUES",
      payload: values
    });
  }, []);
  React.useEffect(() => {
    if (Object.keys(state.errors).length === 0) return;
    const ref2 = setTimeout(() => {
      const [firstError] = formRef.current.querySelectorAll("[data-strapi-field-error]");
      if (firstError) {
        const errorId = firstError.getAttribute("id");
        const formElementInError = formRef.current.querySelector(`[aria-describedby="${errorId}"]`);
        if (formElementInError && formElementInError instanceof HTMLElement) {
          formElementInError.focus();
        }
      }
    });
    return () => clearTimeout(ref2);
  }, [
    state.errors
  ]);
  const validate = React.useCallback(async (shouldSetErrors = true, options = {}) => {
    setErrors({});
    if (!props.validationSchema && !props.validate) {
      return {
        data: state.values
      };
    }
    try {
      let data;
      if (props.validationSchema) {
        data = await props.validationSchema.validate(state.values, {
          abortEarly: false
        });
      } else if (props.validate) {
        data = await props.validate(state.values, options);
      } else {
        throw new Error("No validation schema or validate function provided");
      }
      return {
        data
      };
    } catch (err) {
      if (isErrorYupValidationError(err)) {
        const errors = getYupValidationErrors(err);
        if (shouldSetErrors) {
          setErrors(errors);
        }
        return {
          errors
        };
      } else {
        if (true) {
          console.warn(`Warning: An unhandled error was caught during validation in <Form validationSchema />`, err);
        }
        throw err;
      }
    }
  }, [
    props,
    setErrors,
    state.values
  ]);
  const handleSubmit = async (e) => {
    e.stopPropagation();
    e.preventDefault();
    if (!onSubmit) {
      return;
    }
    dispatch({
      type: "SUBMIT_ATTEMPT"
    });
    try {
      const { data, errors } = await validate();
      if (errors) {
        setErrors(errors);
        throw new Error("Submission failed");
      }
      await onSubmit(data, {
        setErrors,
        setValues,
        resetForm
      });
      dispatch({
        type: "SUBMIT_SUCCESS"
      });
    } catch (err) {
      dispatch({
        type: "SUBMIT_FAILURE"
      });
      if (err instanceof Error && err.message === "Submission failed") {
        return;
      }
    }
  };
  const modified = React.useMemo(
    () => !(0, import_isEqual.default)(initialValues.current, state.values),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      state.values,
      initialValues.current
    ]
  );
  const handleChange = useCallbackRef((eventOrPath, v) => {
    if (typeof eventOrPath === "string") {
      dispatch({
        type: "SET_FIELD_VALUE",
        payload: {
          field: eventOrPath,
          value: v
        }
      });
      return;
    }
    const target = eventOrPath.target || eventOrPath.currentTarget;
    const { type, name, id, value, options, multiple } = target;
    const field = name || id;
    if (!field && true) {
      console.warn(`\`onChange\` was called with an event, but you forgot to pass a \`name\` or \`id'\` attribute to your input. The field to update cannot be determined`);
    }
    let val;
    if (/number|range/.test(type)) {
      const parsed = parseFloat(value);
      val = isNaN(parsed) ? "" : parsed;
    } else if (/checkbox/.test(type)) {
      val = !getIn(state.values, field);
    } else if (options && multiple) {
      val = Array.from(options).filter((el) => el.selected).map((el) => el.value);
    } else {
      if (value === "") {
        val = null;
      } else {
        val = value;
      }
    }
    if (field) {
      dispatch({
        type: "SET_FIELD_VALUE",
        payload: {
          field,
          value: val
        }
      });
    }
  });
  const addFieldRow = React.useCallback((field, value, addAtIndex) => {
    dispatch({
      type: "ADD_FIELD_ROW",
      payload: {
        field,
        value,
        addAtIndex
      }
    });
  }, []);
  const removeFieldRow = React.useCallback((field, removeAtIndex) => {
    dispatch({
      type: "REMOVE_FIELD_ROW",
      payload: {
        field,
        removeAtIndex
      }
    });
  }, []);
  const moveFieldRow = React.useCallback((field, fromIndex, toIndex) => {
    dispatch({
      type: "MOVE_FIELD_ROW",
      payload: {
        field,
        fromIndex,
        toIndex
      }
    });
  }, []);
  const resetForm = React.useCallback((newInitialValues) => {
    if (newInitialValues) {
      initialValues.current = newInitialValues;
    }
    dispatch({
      type: "RESET_FORM",
      payload: {
        errors: {},
        isSubmitting: false,
        values: initialValues.current
      }
    });
  }, []);
  const setSubmitting = React.useCallback((isSubmitting) => {
    dispatch({
      type: "SET_ISSUBMITTING",
      payload: isSubmitting
    });
  }, []);
  const composedRefs = useComposedRefs(formRef, ref);
  return (0, import_jsx_runtime.jsx)(Box, {
    tag: "form",
    ref: composedRefs,
    method,
    noValidate: true,
    onSubmit: handleSubmit,
    width: props.width,
    height: props.height,
    children: (0, import_jsx_runtime.jsx)(FormProvider, {
      disabled,
      onChange: handleChange,
      initialValues: initialValues.current,
      modified,
      addFieldRow,
      moveFieldRow,
      removeFieldRow,
      resetForm,
      setErrors,
      setValues,
      setSubmitting,
      validate,
      ...state,
      children: typeof props.children === "function" ? props.children({
        modified,
        disabled,
        onChange: handleChange,
        ...state,
        setErrors,
        resetForm
      }) : props.children
    })
  });
});
var isErrorYupValidationError = (err) => typeof err === "object" && err !== null && "name" in err && typeof err.name === "string" && err.name === "ValidationError";
var getYupValidationErrors = (err) => {
  let errors = {};
  if (err.inner) {
    if (err.inner.length === 0) {
      return setIn(errors, err.path, err.message);
    }
    for (const error of err.inner) {
      if (!getIn(errors, error.path)) {
        errors = setIn(errors, error.path, error.message);
      }
    }
  }
  return errors;
};
var reducer = (state, action) => fn(state, (draft) => {
  var _a, _b, _c, _d, _e, _f;
  switch (action.type) {
    case "SET_INITIAL_VALUES":
      draft.values = action.payload;
      break;
    case "SET_VALUES":
      draft.values = action.payload;
      break;
    case "SUBMIT_ATTEMPT":
      draft.isSubmitting = true;
      break;
    case "SUBMIT_FAILURE":
      draft.isSubmitting = false;
      break;
    case "SUBMIT_SUCCESS":
      draft.isSubmitting = false;
      break;
    case "SET_FIELD_VALUE":
      draft.values = setIn(state.values, action.payload.field, action.payload.value);
      break;
    case "ADD_FIELD_ROW": {
      const currentField = getIn(state.values, action.payload.field, []);
      let position = action.payload.addAtIndex;
      if (position === void 0) {
        position = currentField.length;
      } else if (position < 0) {
        position = 0;
      }
      const [key] = generateNKeysBetween(position > 0 ? (_a = currentField.at(position - 1)) == null ? void 0 : _a.__temp_key__ : null, (_b = currentField.at(position)) == null ? void 0 : _b.__temp_key__, 1);
      draft.values = setIn(state.values, action.payload.field, currentField.toSpliced(position, 0, {
        ...action.payload.value,
        __temp_key__: key
      }));
      break;
    }
    case "MOVE_FIELD_ROW": {
      const { field, fromIndex, toIndex } = action.payload;
      const currentField = [
        ...getIn(state.values, field, [])
      ];
      const currentRow = currentField[fromIndex];
      const startKey = fromIndex > toIndex ? (_c = currentField[toIndex - 1]) == null ? void 0 : _c.__temp_key__ : (_d = currentField[toIndex]) == null ? void 0 : _d.__temp_key__;
      const endKey = fromIndex > toIndex ? (_e = currentField[toIndex]) == null ? void 0 : _e.__temp_key__ : (_f = currentField[toIndex + 1]) == null ? void 0 : _f.__temp_key__;
      const [newKey] = generateNKeysBetween(startKey, endKey, 1);
      currentField.splice(fromIndex, 1);
      currentField.splice(toIndex, 0, {
        ...currentRow,
        __temp_key__: newKey
      });
      draft.values = setIn(state.values, field, currentField);
      break;
    }
    case "REMOVE_FIELD_ROW": {
      const currentField = getIn(state.values, action.payload.field, []);
      let position = action.payload.removeAtIndex;
      if (position === void 0) {
        position = currentField.length - 1;
      } else if (position < 0) {
        position = 0;
      }
      const newValue = setIn(currentField, position.toString(), void 0).filter((val) => val);
      draft.values = setIn(state.values, action.payload.field, newValue.length > 0 ? newValue : []);
      break;
    }
    case "SET_ERRORS":
      if (!(0, import_isEqual.default)(state.errors, action.payload)) {
        draft.errors = action.payload;
      }
      break;
    case "SET_ISSUBMITTING":
      draft.isSubmitting = action.payload;
      break;
    case "RESET_FORM":
      draft.values = action.payload.values;
      draft.errors = action.payload.errors;
      draft.isSubmitting = action.payload.isSubmitting;
      break;
  }
});
function useField(path) {
  const { formatMessage } = useIntl();
  const initialValue = useForm("useField", (state) => getIn(state.initialValues, path));
  const value = useForm("useField", (state) => getIn(state.values, path));
  const handleChange = useForm("useField", (state) => state.onChange);
  const rawError = useForm("useField", (state) => getIn(state.errors, path));
  const error = useForm("useField", (state) => {
    const error2 = getIn(state.errors, path);
    if (isErrorMessageDescriptor(error2)) {
      const { values, ...message } = error2;
      return formatMessage(message, values);
    }
    return error2;
  });
  return {
    initialValue,
    /**
    * Errors can be a string, or a MessageDescriptor, so we need to handle both cases.
    * If it's anything else, we don't return it.
    */
    rawError,
    error: isErrorMessageDescriptor(error) ? formatMessage({
      id: error.id,
      defaultMessage: error.defaultMessage
    }, error.values) : typeof error === "string" ? error : void 0,
    onChange: handleChange,
    value
  };
}
var isErrorMessageDescriptor = (object) => {
  return typeof object === "object" && object !== null && !Array.isArray(object) && "id" in object && "defaultMessage" in object;
};

export {
  useForm,
  Form,
  useField
};
//# sourceMappingURL=chunk-PWOUCKWI.js.map
