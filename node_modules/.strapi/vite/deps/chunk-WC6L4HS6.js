import {
  require_baseMerge,
  require_createAssigner
} from "./chunk-TCJPRNVA.js";
import {
  require_baseRest
} from "./chunk-XOEQSEO3.js";
import {
  require_apply,
  require_toNumber
} from "./chunk-5K5BMNX6.js";
import {
  require_isObject,
  require_root
} from "./chunk-HM5YIFDI.js";
import {
  __commonJS
} from "./chunk-LK32TJAX.js";

// node_modules/json-logic-js/logic.js
var require_logic = __commonJS({
  "node_modules/json-logic-js/logic.js"(exports, module) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define(factory);
      } else if (typeof exports === "object") {
        module.exports = factory();
      } else {
        root.jsonLogic = factory();
      }
    })(exports, function() {
      "use strict";
      if (!Array.isArray) {
        Array.isArray = function(arg) {
          return Object.prototype.toString.call(arg) === "[object Array]";
        };
      }
      function arrayUnique(array) {
        var a = [];
        for (var i = 0, l = array.length; i < l; i++) {
          if (a.indexOf(array[i]) === -1) {
            a.push(array[i]);
          }
        }
        return a;
      }
      var jsonLogic = {};
      var operations = {
        "==": function(a, b) {
          return a == b;
        },
        "===": function(a, b) {
          return a === b;
        },
        "!=": function(a, b) {
          return a != b;
        },
        "!==": function(a, b) {
          return a !== b;
        },
        ">": function(a, b) {
          return a > b;
        },
        ">=": function(a, b) {
          return a >= b;
        },
        "<": function(a, b, c) {
          return c === void 0 ? a < b : a < b && b < c;
        },
        "<=": function(a, b, c) {
          return c === void 0 ? a <= b : a <= b && b <= c;
        },
        "!!": function(a) {
          return jsonLogic.truthy(a);
        },
        "!": function(a) {
          return !jsonLogic.truthy(a);
        },
        "%": function(a, b) {
          return a % b;
        },
        "log": function(a) {
          console.log(a);
          return a;
        },
        "in": function(a, b) {
          if (!b || typeof b.indexOf === "undefined") return false;
          return b.indexOf(a) !== -1;
        },
        "cat": function() {
          return Array.prototype.join.call(arguments, "");
        },
        "substr": function(source, start, end) {
          if (end < 0) {
            var temp = String(source).substr(start);
            return temp.substr(0, temp.length + end);
          }
          return String(source).substr(start, end);
        },
        "+": function() {
          return Array.prototype.reduce.call(arguments, function(a, b) {
            return parseFloat(a, 10) + parseFloat(b, 10);
          }, 0);
        },
        "*": function() {
          return Array.prototype.reduce.call(arguments, function(a, b) {
            return parseFloat(a, 10) * parseFloat(b, 10);
          });
        },
        "-": function(a, b) {
          if (b === void 0) {
            return -a;
          } else {
            return a - b;
          }
        },
        "/": function(a, b) {
          return a / b;
        },
        "min": function() {
          return Math.min.apply(this, arguments);
        },
        "max": function() {
          return Math.max.apply(this, arguments);
        },
        "merge": function() {
          return Array.prototype.reduce.call(arguments, function(a, b) {
            return a.concat(b);
          }, []);
        },
        "var": function(a, b) {
          var not_found = b === void 0 ? null : b;
          var data = this;
          if (typeof a === "undefined" || a === "" || a === null) {
            return data;
          }
          var sub_props = String(a).split(".");
          for (var i = 0; i < sub_props.length; i++) {
            if (data === null || data === void 0) {
              return not_found;
            }
            data = data[sub_props[i]];
            if (data === void 0) {
              return not_found;
            }
          }
          return data;
        },
        "missing": function() {
          var missing = [];
          var keys = Array.isArray(arguments[0]) ? arguments[0] : arguments;
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = jsonLogic.apply({ "var": key }, this);
            if (value === null || value === "") {
              missing.push(key);
            }
          }
          return missing;
        },
        "missing_some": function(need_count, options) {
          var are_missing = jsonLogic.apply({ "missing": options }, this);
          if (options.length - are_missing.length >= need_count) {
            return [];
          } else {
            return are_missing;
          }
        }
      };
      jsonLogic.is_logic = function(logic) {
        return typeof logic === "object" && // An object
        logic !== null && // but not null
        !Array.isArray(logic) && // and not an array
        Object.keys(logic).length === 1;
      };
      jsonLogic.truthy = function(value) {
        if (Array.isArray(value) && value.length === 0) {
          return false;
        }
        return !!value;
      };
      jsonLogic.get_operator = function(logic) {
        return Object.keys(logic)[0];
      };
      jsonLogic.get_values = function(logic) {
        return logic[jsonLogic.get_operator(logic)];
      };
      jsonLogic.apply = function(logic, data) {
        if (Array.isArray(logic)) {
          return logic.map(function(l) {
            return jsonLogic.apply(l, data);
          });
        }
        if (!jsonLogic.is_logic(logic)) {
          return logic;
        }
        var op = jsonLogic.get_operator(logic);
        var values = logic[op];
        var i;
        var current;
        var scopedLogic;
        var scopedData;
        var initial;
        if (!Array.isArray(values)) {
          values = [values];
        }
        if (op === "if" || op == "?:") {
          for (i = 0; i < values.length - 1; i += 2) {
            if (jsonLogic.truthy(jsonLogic.apply(values[i], data))) {
              return jsonLogic.apply(values[i + 1], data);
            }
          }
          if (values.length === i + 1) {
            return jsonLogic.apply(values[i], data);
          }
          return null;
        } else if (op === "and") {
          for (i = 0; i < values.length; i += 1) {
            current = jsonLogic.apply(values[i], data);
            if (!jsonLogic.truthy(current)) {
              return current;
            }
          }
          return current;
        } else if (op === "or") {
          for (i = 0; i < values.length; i += 1) {
            current = jsonLogic.apply(values[i], data);
            if (jsonLogic.truthy(current)) {
              return current;
            }
          }
          return current;
        } else if (op === "filter") {
          scopedData = jsonLogic.apply(values[0], data);
          scopedLogic = values[1];
          if (!Array.isArray(scopedData)) {
            return [];
          }
          return scopedData.filter(function(datum) {
            return jsonLogic.truthy(jsonLogic.apply(scopedLogic, datum));
          });
        } else if (op === "map") {
          scopedData = jsonLogic.apply(values[0], data);
          scopedLogic = values[1];
          if (!Array.isArray(scopedData)) {
            return [];
          }
          return scopedData.map(function(datum) {
            return jsonLogic.apply(scopedLogic, datum);
          });
        } else if (op === "reduce") {
          scopedData = jsonLogic.apply(values[0], data);
          scopedLogic = values[1];
          initial = typeof values[2] !== "undefined" ? jsonLogic.apply(values[2], data) : null;
          if (!Array.isArray(scopedData)) {
            return initial;
          }
          return scopedData.reduce(
            function(accumulator, current2) {
              return jsonLogic.apply(
                scopedLogic,
                { current: current2, accumulator }
              );
            },
            initial
          );
        } else if (op === "all") {
          scopedData = jsonLogic.apply(values[0], data);
          scopedLogic = values[1];
          if (!Array.isArray(scopedData) || !scopedData.length) {
            return false;
          }
          for (i = 0; i < scopedData.length; i += 1) {
            if (!jsonLogic.truthy(jsonLogic.apply(scopedLogic, scopedData[i]))) {
              return false;
            }
          }
          return true;
        } else if (op === "none") {
          scopedData = jsonLogic.apply(values[0], data);
          scopedLogic = values[1];
          if (!Array.isArray(scopedData) || !scopedData.length) {
            return true;
          }
          for (i = 0; i < scopedData.length; i += 1) {
            if (jsonLogic.truthy(jsonLogic.apply(scopedLogic, scopedData[i]))) {
              return false;
            }
          }
          return true;
        } else if (op === "some") {
          scopedData = jsonLogic.apply(values[0], data);
          scopedLogic = values[1];
          if (!Array.isArray(scopedData) || !scopedData.length) {
            return false;
          }
          for (i = 0; i < scopedData.length; i += 1) {
            if (jsonLogic.truthy(jsonLogic.apply(scopedLogic, scopedData[i]))) {
              return true;
            }
          }
          return false;
        }
        values = values.map(function(val) {
          return jsonLogic.apply(val, data);
        });
        if (operations.hasOwnProperty(op) && typeof operations[op] === "function") {
          return operations[op].apply(data, values);
        } else if (op.indexOf(".") > 0) {
          var sub_ops = String(op).split(".");
          var operation = operations;
          for (i = 0; i < sub_ops.length; i++) {
            if (!operation.hasOwnProperty(sub_ops[i])) {
              throw new Error("Unrecognized operation " + op + " (failed at " + sub_ops.slice(0, i + 1).join(".") + ")");
            }
            operation = operation[sub_ops[i]];
          }
          return operation.apply(data, values);
        }
        throw new Error("Unrecognized operation " + op);
      };
      jsonLogic.uses_data = function(logic) {
        var collection = [];
        if (jsonLogic.is_logic(logic)) {
          var op = jsonLogic.get_operator(logic);
          var values = logic[op];
          if (!Array.isArray(values)) {
            values = [values];
          }
          if (op === "var") {
            collection.push(values[0]);
          } else {
            values.forEach(function(val) {
              collection.push.apply(collection, jsonLogic.uses_data(val));
            });
          }
        }
        return arrayUnique(collection);
      };
      jsonLogic.add_operation = function(name, code) {
        operations[name] = code;
      };
      jsonLogic.rm_operation = function(name) {
        delete operations[name];
      };
      jsonLogic.rule_like = function(rule, pattern) {
        if (pattern === rule) {
          return true;
        }
        if (pattern === "@") {
          return true;
        }
        if (pattern === "number") {
          return typeof rule === "number";
        }
        if (pattern === "string") {
          return typeof rule === "string";
        }
        if (pattern === "array") {
          return Array.isArray(rule) && !jsonLogic.is_logic(rule);
        }
        if (jsonLogic.is_logic(pattern)) {
          if (jsonLogic.is_logic(rule)) {
            var pattern_op = jsonLogic.get_operator(pattern);
            var rule_op = jsonLogic.get_operator(rule);
            if (pattern_op === "@" || pattern_op === rule_op) {
              return jsonLogic.rule_like(
                jsonLogic.get_values(rule, false),
                jsonLogic.get_values(pattern, false)
              );
            }
          }
          return false;
        }
        if (Array.isArray(pattern)) {
          if (Array.isArray(rule)) {
            if (pattern.length !== rule.length) {
              return false;
            }
            for (var i = 0; i < pattern.length; i += 1) {
              if (!jsonLogic.rule_like(rule[i], pattern[i])) {
                return false;
              }
            }
            return true;
          } else {
            return false;
          }
        }
        return false;
      };
      return jsonLogic;
    });
  }
});

// node_modules/invariant/browser.js
var require_browser = __commonJS({
  "node_modules/invariant/browser.js"(exports, module) {
    "use strict";
    var invariant = function(condition, format, a, b, c, d, e, f) {
      if (true) {
        if (format === void 0) {
          throw new Error("invariant requires an error message argument");
        }
      }
      if (!condition) {
        var error;
        if (format === void 0) {
          error = new Error(
            "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
          );
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error(
            format.replace(/%s/g, function() {
              return args[argIndex++];
            })
          );
          error.name = "Invariant Violation";
        }
        error.framesToPop = 1;
        throw error;
      }
    };
    module.exports = invariant;
  }
});

// node_modules/lodash/now.js
var require_now = __commonJS({
  "node_modules/lodash/now.js"(exports, module) {
    var root = require_root();
    var now = function() {
      return root.Date.now();
    };
    module.exports = now;
  }
});

// node_modules/lodash/debounce.js
var require_debounce = __commonJS({
  "node_modules/lodash/debounce.js"(exports, module) {
    var isObject = require_isObject();
    var now = require_now();
    var toNumber = require_toNumber();
    var FUNC_ERROR_TEXT = "Expected a function";
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    module.exports = debounce;
  }
});

// node_modules/lodash/throttle.js
var require_throttle = __commonJS({
  "node_modules/lodash/throttle.js"(exports, module) {
    var debounce = require_debounce();
    var isObject = require_isObject();
    var FUNC_ERROR_TEXT = "Expected a function";
    function throttle(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    module.exports = throttle;
  }
});

// node_modules/lodash/_customDefaultsMerge.js
var require_customDefaultsMerge = __commonJS({
  "node_modules/lodash/_customDefaultsMerge.js"(exports, module) {
    var baseMerge = require_baseMerge();
    var isObject = require_isObject();
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, void 0, customDefaultsMerge, stack);
        stack["delete"](srcValue);
      }
      return objValue;
    }
    module.exports = customDefaultsMerge;
  }
});

// node_modules/lodash/mergeWith.js
var require_mergeWith = __commonJS({
  "node_modules/lodash/mergeWith.js"(exports, module) {
    var baseMerge = require_baseMerge();
    var createAssigner = require_createAssigner();
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });
    module.exports = mergeWith;
  }
});

// node_modules/lodash/defaultsDeep.js
var require_defaultsDeep = __commonJS({
  "node_modules/lodash/defaultsDeep.js"(exports, module) {
    var apply = require_apply();
    var baseRest = require_baseRest();
    var customDefaultsMerge = require_customDefaultsMerge();
    var mergeWith = require_mergeWith();
    var defaultsDeep = baseRest(function(args) {
      args.push(void 0, customDefaultsMerge);
      return apply(mergeWith, void 0, args);
    });
    module.exports = defaultsDeep;
  }
});

export {
  require_browser,
  require_defaultsDeep,
  require_debounce,
  require_throttle,
  require_logic
};
//# sourceMappingURL=chunk-WC6L4HS6.js.map
